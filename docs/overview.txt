########
Overview
########

This document introduces `piecutter`'s concepts and main features.
See also :doc:`/about/vision`.

.. testsetup::

   from __future__ import print_function


****************
Import piecutter
****************

Provided :doc:`piecutter is installed </install>`, let's import ``piecutter``
library:

.. doctest::

   >>> import piecutter  # All-in-one API.


*********
Renderers
*********

:doc:`Renderers </renderers>` are the core components of `piecutter`. They use
template engines to generate output using templates and context data.

Renderers are callables that accept template and data as input then return
generated output.

.. doctest::

   >>> render = piecutter.PythonFormatEngine()
   >>> output = render(u'Hello {who}!', {u'who': u'world'})
   >>> print(output)
   Hello world!

`piecutter`'s initial concept is to provide a single API to handle multiple
template engines. `piecutter`'s core currently supports the following
third-party engines:

* `Python's builtin string format`_;
* `Jinja2`_;
* `Django`_.

Of course, you can implement custom renderers.

`piecutter` also provides a special renderer that tries to guess the engine
based on the content of the template.

Learn more in :doc:`/renderers`.


*******
Loaders
*******

:doc:`Loaders </loaders>` load :doc:`templates </templates>`.

Loaders are callables that accept location as input argument then return a
template object.

.. doctest::

   >>> load = piecutter.LocalLoader(root=u'../demo')
   >>> with load(u'hello.txt') as template:
   ...     print(template)
   Hello {who}!
   <BLANKLINE>

`piecutter` provides builtin support for various locations:

* files on local filesystem;
* remote files over HTTP;
* remote files on Github.

Of course, you can write your own loaders!

See :doc:`loaders </loaders>` for details.


*********
Templates
*********

`piecutter` handles :doc:`template objects </templates>`. They are, basically,
`Python` objects whose content can be read.

Templates can represent either single units (files) or collections
(directories).

`piecutter` can render text, files or special ``Template`` objects:

.. doctest::

   >>> render = piecutter.PythonFormatEngine() 

   >>> print(render('Hello {who}!', {'who': 'world'}))
   Hello world!

   >>> from StringIO import StringIO
   >>> print(render(StringIO(u'Hello {who}!'), {'who': 'world'}))
   Hello world!


****
Data
****

`piecutter` uses mappings as context data. Any dictionary-like object can be
used.

During rendering, additional contextual data is added to the original, such as
``piecutter.engine``, which represents template engine name.

See :doc:`context` for details.


*******
Writers
*******

`piecutter` uses writers to post-process template rendering output. Writers
typically are classes that implement a ``write(template, context, output)``
method.


*******
Cutters
*******

Cutters encapsulate full template rendering workflow, from template loading to
output post-processing, via template rendering of course.
Cutters are the glue for all the features of `piecutter`:

Cutters are callables that take ``location`` and ``data`` as input and write
output somewhere. They typically are objects that can be configured using
loaders, renderers, writers...

.. doctest::

   >>> import sys
   >>> render = piecutter.Cutter(
   ...     loader=piecutter.HttpLoader(),
   ...     engine=piecutter.Jinja2Engine(),
   ...     writer=piecutter.StreamWriter(sys.stdout),
   ... )
   >>> render(
   ...     'https://raw.githubusercontent.com'
   ...     '/diecutter/diecutter/0.7/demo/templates/greetings.txt',
   ...     {'name': 'world'})
   Hello world!

Here is another setup, where several template engines are registered:

.. doctest::

   >>> cutter = piecutter.Cutter(
   ...     engine=piecutter.SmartEngine(
   ...         engines=[
   ...             piecutter.Jinja2Engine(),
   ...             piecutter.DjangoEngine(),
   ...             piecutter.PythonFormatEngine(),
   ...         ],
   ...     )
   ... )

Then we can use the cutter to render various templates:

.. doctest::

   >>> print(cutter.render("{# Jinja2 #}Hello {{ who }}!", {'who': 'world'}))
   Hello world!
   >>> print(cutter.render("{# Django #}Hello {{ who }}!", {'who': 'world'}))
   Hello world!
   >>> print(cutter.render("Hello {who}!", {'who': 'world'}))
   Hello world!


***********
Dispatchers
***********

`piecutter` renders templates using processing pipelines. As an example,
writers can be chained to perform several operations. Or before a specific
template engine is called, context data is updated with some `piecutter`'s
internals... Everywhere processing could be done by either one or several
functions, you can use dispatchers: they look like one function but encapsulate
several calls.


.. rubric:: Notes & references

.. target-notes::

.. _`Python's builtin string format`:
   https://docs.python.org/2.7/library/string.html#formatstrings
.. _`Jinja2`: http://jinja.pocoo.org/
.. _`Django`: https://docs.djangoproject.com/en/1.8/topics/templates/
